#!/usr/bin/env node
"use strict";

const fs = require("fs");
const path = require("path");

const fetchOptions = require("./lib/fetchOptions");
const output = require("./lib/output");
const cli = require("./lib/cli");
const context = require("./lib/context");
const schemaValidator = require("./lib/schemaValidator");
const rules = require("./rules/rules");
const Git = require("nodegit");

const noRulesErrorMessage = "No rules provided.";
const noRuleFoundErrorMessage = "The rule \"{{{rule}}}\" was not found.";
const failedToLoadErrorMessage = "The rule \"{{{rule}}}\" could not be loaded from \"{{{path}}}\".";

function isArray(object) {
	return object.constructor === Array;
}

function applyRule(spec) {
	let message = spec.message;
	let rule = spec.rule;
	let file = spec.file;
	let fn = spec.fn;
	let options = spec.options;
	let cliOptions = spec.cliOptions;
	let output = spec.output;
	let gitContext = spec.gitContext;

	let level;

	if (isArray(options)) {
		options = options.slice();
		level = options.shift();
	} else {
		level = options;
		options = null;
	}

	if (level === 0) {
		return 0;
	}

	let newContext = context({
		file: file,
		output: output,
		cliOptions: cliOptions,
		level: level,
		options: options,
		rule: rule,
		git: gitContext
	});

	// Apply the rule
	let allLines = message.split("\n");

	let lines = allLines.filter((line) => {
		return line[0] !== "#";
	});
	
	let comments = allLines.filter((line) => {
		return line[0] === "#";
	});

	fn(newContext)(message, lines, comments);

	return newContext.hasErrors();
}

function findExtraRule(name, options) {
	let rulesDir = options.rulesdir;

	if (!rulesDir) {
		output.error(noRuleFoundErrorMessage, {
			rule: name
		});

		return null;
	}

	let fn;
	let rulePath = path.resolve(rulesDir, name);

	try {
		fn = require(rulePath);
	} catch (e) {
		output.error(failedToLoadErrorMessage, {
			rule: name,
			path: rulePath.toString()
		});

		return null;
	}

	return fn;
}

function validateMessage(string, options, cliOptions, gitContext, file) {
	let hasError = false;

	if (!options.rules) {
		output.error(noRulesErrorMessage);
		return 1;
	}

	for (let rule of Object.keys(options.rules).sort()) {
		let ruleOptions = options.rules[rule];
		let ruleFunction = rules[rule];

		if (!ruleFunction) {
			ruleFunction = findExtraRule(rule, options);
		}

		let result = true;

		if (ruleFunction) {
			let isSchemaValid = true;

			if (isArray(ruleOptions)) {
				isSchemaValid = schemaValidator(rule, ruleFunction.schema, ruleOptions);
			}

			if (isSchemaValid) {
				result = applyRule({
					file: file,
					cliOptions: cliOptions,
					message: string,
					rule: rule,
					fn: ruleFunction,
					options: ruleOptions,
					gitContext: gitContext,
					output: output
				});
			}
		}

		hasError = hasError || result;
	}

	return hasError ? 1 : 0;
}

function initialize() {
	let args = cli.getArguments();

	if (args["no-git-context"]) {
		analyzeMessage(args.src, args, {});
		return;
	}

	let gitContext = {};

	Git.Repository.open(".").then(function(repo) {
		gitContext.repository = repo;
		return repo.getCurrentBranch();
	}).then(function(branch) {
		gitContext.branch = branch;
		return gitContext.repository.getHeadCommit();
	}).then(function(commit) {
		return commit.getTree();
	}).then(function(tree) {
		return Git.Diff.treeToIndex(gitContext.repository, tree, "HEAD");
	}).then(function(diff) {
		return diff.patches();
	}).then(function(arrayConvenientPatch) {
		gitContext.patches = arrayConvenientPatch;
		analyzeMessage(args.src, args, gitContext);
	}).catch(function(reasonForFailure) {
		output.error(reasonForFailure.message);
		process.exit(1);
	});
}

function analyzeMessage(commitMessageTmpFile, cliOptions, gitContext) {
	if (!commitMessageTmpFile || !fs.existsSync(commitMessageTmpFile)) {
		cli.displayHelp();
		process.exit(1);
	}

	let dir = path.dirname(commitMessageTmpFile);
	let options = fetchOptions(dir);

	let message = fs.readFileSync(commitMessageTmpFile, "utf8");
	let result = validateMessage(message, options, cliOptions, gitContext, path.resolve(commitMessageTmpFile));

	process.exit(result);
}

initialize();