#!/usr/bin/env node
"use strict";

const fs = require("fs");
const path = require("path");

const fetchOptions = require("./lib/fetchOptions");
const output = require("./lib/output");
const cli = require("./lib/cli");
const context = require("./lib/context");
const rules = require("./rules/rules");

const noRulesErrorMessage = "No rules provided.";
const noRuleFoundErrorMessage = "The rule \"{{{rule}}}\" was not found.";
const failedToLoadErrorMessage = "The rule \"{{{rule}}}\" could not be loaded from \"{{{path}}}\".";

function isArray(object) {
	return object.constructor === Array;
}

function applyRule(spec) {
	let message = spec.message;
	let rule = spec.rule;
	let file = spec.file;
	let fn = spec.fn;
	let options = spec.options;
	let cliOptions = spec.cliOptions;
	let output = spec.output;

	let level;

	if (isArray(options)) {
		options = options.slice();
		level = options.shift();
	} else {
		level = options;
		options = null;
	}

	if (level === 0) {
		return 0;
	}

	let newContext = context({
		file: file,
		output: output,
		cliOptions: cliOptions,
		level: level,
		options: options,
		rule: rule
	});

	// Apply the rule
	fn(newContext)(message);

	return newContext.hasErrors();
}

function findExtraRule(name, options) {
	let rulesDir = options.rulesdir;

	if (!rulesDir) {
		output.error(noRuleFoundErrorMessage, {
			rule: name
		});

		return null;
	}

	let fn;
	let rulePath = path.resolve(rulesDir, name);

	try {
		fn = require(rulePath);
	} catch (e) {
		output.error(failedToLoadErrorMessage, {
			rule: name,
			path: rulePath.toString()
		});

		return null;
	}

	return fn;
}

function validateMessage(string, options, cliOptions, file) {
	let hasError = false;

	if (!options.rules) {
		output.error(noRulesErrorMessage);
		return 1;
	}

	for (let rule of Object.keys(options.rules)) {
		let ruleOptions = options.rules[rule];
		let ruleFunction = rules[rule];

		if (!ruleFunction) {
			ruleFunction = findExtraRule(rule, options);
		}

		let result = true;
		if (ruleFunction) {
			result = applyRule({
				file: file,
				cliOptions: cliOptions,
				message: string,
				rule: rule,
				fn: ruleFunction,
				options: ruleOptions,
				output: output
			});
		}

		hasError = hasError || result;
	}

	return hasError ? 1 : 0;
}

function initialize() {
	let args = cli.getArguments();
	analyzeMessage(args.src, args);
}

function analyzeMessage(commitMessageTmpFile, cliOptions) {
	if (!commitMessageTmpFile || !fs.existsSync(commitMessageTmpFile)) {
		cli.displayHelp();
		process.exit(1);
	}

	let dir = path.dirname(commitMessageTmpFile);
	let options = fetchOptions(dir);
	
	let message = fs.readFileSync(commitMessageTmpFile, "utf8");
	let result = validateMessage(message, options, cliOptions, path.resolve(commitMessageTmpFile));

	process.exit(result);
}

initialize();